/**
 * Update Service API
 * This is the API documentation for the Mbed deployment service, which is part of the update service.
 *
 * OpenAPI spec version: 3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import * as superagent from "superagent";
import { ApiBase } from "../common/apiBase";
export declare namespace CampaignDeviceMetadata {
    type DeploymentStateEnum = "pending" | "updated_connector_channel" | "failed_connector_channel_update" | "deployed" | "manifestremoved" | "deregistered";
}
export interface CampaignDeviceMetadata {
    /**
     * The device's campaign ID
     */
    "campaign"?: string;
    /**
     * The time the campaign was created
     */
    "created_at"?: Date;
    /**
     * The state of the update campaign on the device
     */
    "deployment_state"?: CampaignDeviceMetadata.DeploymentStateEnum;
    /**
     * Description
     */
    "description"?: string;
    /**
     * The device ID
     */
    "device_id"?: string;
    /**
     * API resource entity version
     */
    "etag"?: string;
    /**
     * The metadata record ID
     */
    "id"?: string;
    /**
     * How the firmware is delivered (connector or direct)
     */
    "mechanism"?: string;
    /**
     * The Cloud Connect URL
     */
    "mechanism_url"?: string;
    /**
     * The record name
     */
    "name"?: string;
    /**
     * Entity name: always 'update-campaign-device-metadata'
     */
    "object"?: string;
    /**
     * This time this record was modified in the database format: date-time
     */
    "updated_at"?: Date;
}
export declare namespace CampaignDeviceMetadataPage {
    type OrderEnum = "ASC" | "DESC";
}
export interface CampaignDeviceMetadataPage {
    /**
     * The entity ID to fetch after the given one
     */
    "after"?: string;
    /**
     * A list of entities
     */
    "data"?: Array<CampaignDeviceMetadata>;
    /**
     * Flag indicating whether there are more results
     */
    "has_more"?: boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to total_count
     */
    "limit"?: number;
    /**
     * Entity name: always 'list'
     */
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: CampaignDeviceMetadataPage.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count"?: number;
}
export interface FirmwareImage {
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The firmware image file URL
     */
    "datafile": string;
    /**
     * Checksum (sha256) generated for the datafile
     */
    "datafile_checksum": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The description of the object
     */
    "description": string;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The firmware image ID
     */
    "id": string;
    /**
     * The firmware image name
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
}
export interface FirmwareImageEqNeqFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_checksum"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "updated_at"?: Date;
}
export interface FirmwareImageGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "updated_at"?: Date;
}
export interface FirmwareImageInNinFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_checksum"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "updated_at"?: Date;
}
export declare namespace FirmwareImagePage {
    type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareImagePage {
    "after"?: string;
    "data"?: Array<FirmwareImage>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records based on creation time, `ASC` or `DESC`; by default `ASC`.
     */
    "order"?: FirmwareImagePage.OrderEnum;
    "total_count"?: number;
}
export interface FirmwareManifest {
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The URL of the firmware manifest binary
     */
    "datafile": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The description of the firmware manifest
     */
    "description": string;
    /**
     * The class of the device
     */
    "device_class": string;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The firmware manifest ID
     */
    "id": string;
    /**
     * The key table of pre-shared keys for devices
     */
    "key_table"?: string;
    /**
     * The name of the object
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The firmware manifest version as a timestamp
     */
    "timestamp": Date;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
}
export interface FirmwareManifestEqNeqFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "device_class"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "timestamp"?: Date;
    "updated_at"?: Date;
}
export interface FirmwareManifestGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "timestamp"?: Date;
    "updated_at"?: Date;
}
export interface FirmwareManifestInNinFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "device_class"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "timestamp"?: Date;
    "updated_at"?: Date;
}
export declare namespace FirmwareManifestPage {
    type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareManifestPage {
    "after"?: string;
    "data"?: Array<FirmwareManifest>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: FirmwareManifestPage.OrderEnum;
    "total_count"?: number;
}
export declare namespace UpdateCampaign {
    type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaign {
    /**
     * The time the update campaign was created
     */
    "created_at"?: Date;
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The entity instance signature
     */
    "etag"?: string;
    /**
     * The campaign finish timestamp
     */
    "finished"?: Date;
    /**
     * The campaign ID
     */
    "id"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The current phase of the campaign.
     */
    "phase"?: string;
    "root_manifest_id"?: string;
    "root_manifest_url"?: string;
    "started_at"?: Date;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaign.StateEnum;
    /**
     * The time the object was updated
     */
    "updated_at"?: Date;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}
export interface UpdateCampaignEqNeqFilter {
    "created_at"?: Date;
    "description"?: string;
    "device_filter"?: string;
    "etag"?: Date;
    "finished"?: Date;
    "id"?: string;
    "name"?: string;
    "root_manifest_id"?: string;
    "started_at"?: Date;
    "state"?: string;
    "updated_at"?: Date;
    "when"?: Date;
}
export interface UpdateCampaignGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "finished"?: Date;
    "started_at"?: Date;
    "updated_at"?: Date;
    "when"?: Date;
}
export interface UpdateCampaignInNinFilter {
    "created_at"?: Date;
    "description"?: string;
    "device_filter"?: string;
    "etag"?: Date;
    "finished"?: Date;
    "id"?: string;
    "name"?: string;
    "root_manifest_id"?: string;
    "started_at"?: Date;
    "state"?: string;
    "updated_at"?: Date;
    "when"?: Date;
}
export declare namespace UpdateCampaignPage {
    type OrderEnum = "ASC" | "DESC";
}
export interface UpdateCampaignPage {
    "after"?: string;
    "data"?: Array<UpdateCampaign>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: UpdateCampaignPage.OrderEnum;
    "total_count"?: number;
}
export declare namespace UpdateCampaignPatchRequest {
    type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPatchRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    "root_manifest_id"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPatchRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}
export declare namespace UpdateCampaignPostRequest {
    type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPostRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The name for this campaign
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object"?: string;
    "root_manifest_id"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPostRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}
export declare namespace UpdateCampaignPutRequest {
    type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPutRequest {
    /**
     * An optional description of the campaign
     */
    "description": string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The campaign's name
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    "root_manifest_id": string;
    /**
     * The state of the campaign
     */
    "state": UpdateCampaignPutRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when": Date;
}
/**
 * DefaultApi
 */
export declare class DefaultApi extends ApiBase {
    /**
     * Create an image
     * Create firmware image.
     * @param datafile The firmware image file to upload
     * @param name The name of the firmware image
     * @param description The description of the firmware image
     */
    firmwareImageCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Delete an image
     * Delete firmware image.
     * @param imageId The firmware image ID
     */
    firmwareImageDestroy(imageId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * List all images
     * List all firmware images.
     * @param limit How many firmware images to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |       Field       | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-----------------:|:----------------:|:-------------:|:-------------:| |     created_at    |         ✓        |       ✓       |       ✓       | |      datafile     |         ✓        |       ✓       |               | | datafile_checksum |         ✓        |       ✓       |               | |   datafile_size   |         ✓        |       ✓       |               | |    description    |         ✓        |       ✓       |               | |        etag       |         ✓        |       ✓       |       ✓       | |         id        |         ✓        |       ✓       |               | |        name       |         ✓        |       ✓       |               | |     timestamp     |         ✓        |       ✓       |       ✓       | |     updated_at    |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;myimage&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;myimage&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    firmwareImageList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareImagePage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Get an image
     * Retrieve firmware image.
     * @param imageId The firmware image ID
     */
    firmwareImageRetrieve(imageId: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Create a manifest
     * Create firmware manifest.
     * @param datafile The manifest file to create. The API gateway enforces the account-specific file size.
     * @param name The name of the firmware manifest
     * @param description The description of the firmware manifest
     * @param keyTable The key table of pre-shared keys for devices
     */
    firmwareManifestCreate(datafile: any, name: string, description?: string, keyTable?: any, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Delete a manifest
     * Delete firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    firmwareManifestDestroy(manifestId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * List manifests
     * List firmware manifests.
     * @param limit How many firmware manifests to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page.
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |     Field     | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-------------:|:----------------:|:-------------:|:-------------:| |   created_at  |         ✓        |       ✓       |       ✓       | |    datafile   |         ✓        |       ✓       |               | | datafile_size |         ✓        |       ✓       |               | |  description  |         ✓        |       ✓       |               | |  device_class |         ✓        |       ✓       |               | |      etag     |         ✓        |       ✓       |       ✓       | |       id      |         ✓        |       ✓       |               | |      name     |         ✓        |       ✓       |               | |   timestamp   |         ✓        |       ✓       |       ✓       | |   updated_at  |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;mymanifest&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;mymanifest&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-manifest1,fw-manifest2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    firmwareManifestList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareManifestPage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Get a manifest
     * Retrieve firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    firmwareManifestRetrieve(manifestId: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Create a campaign
     * Create an update campaign.
     * @param campaign Update campaign
     */
    updateCampaignCreate(campaign: UpdateCampaignPostRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Delete a campaign
     * Delete an update campaign.
     * @param campaignId The ID of the update campaign
     */
    updateCampaignDestroy(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * List all campaigns
     * Get update campaigns for devices specified by a filter.
     * @param limit How many update campaigns to retrieve
     * @param order The order of the records. Acceptable values: ASC, DESC. Default: ASC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;   ###### Filterable fields:    The below table lists all the fields that can be filtered on with certain filters:    |       Field      | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte |   |:----------------:|:----------------:|:-------------:|:-------------:|   |    created_at    |         ✓        |       ✓       |       ✓       |   |    description   |         ✓        |       ✓       |               |   |   device_filter  |         ✓        |       ✓       |               |   |       etag       |         ✓        |       ✓       |       ✓       |   |     finished     |         ✓        |       ✓       |       ✓       |   |        id        |         ✓        |       ✓       |               |   |       name       |         ✓        |       ✓       |               |   | root_manifest_id |         ✓        |       ✓       |               |   |    started_at    |         ✓        |       ✓       |       ✓       |   |       state      |         ✓        |       ✓       |               |   |    updated_at    |         ✓        |       ✓       |       ✓       |   |       when       |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by campaign properties** &#x60;state__eq&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]&#x60;  &#x60;root_manifest_id__eq&#x3D;43217771234242e594ddb433816c498a&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;state__eq&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    updateCampaignList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: UpdateCampaignPage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * List all campaign device metadata
     * Get campaign device metadata.
     * @param campaignId The update campaign ID
     * @param limit How many objects to retrieve in the page
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    updateCampaignMetadataList(campaignId: string, limit?: number, order?: string, after?: string, include?: string, callback?: (error: any, data?: CampaignDeviceMetadataPage, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Get a campaign device metadata
     * Get update campaign metadata.
     * @param campaignId The update campaign ID
     * @param campaignDeviceMetadataId The campaign device metadata ID
     */
    updateCampaignMetadataRetrieve(campaignId: string, campaignDeviceMetadataId: string, callback?: (error: any, data?: CampaignDeviceMetadata, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Stop a running campaign
     * Stop a running update campaign.
     * @param campaignId The campaign ID
     */
    updateCampaignMetadataStop(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Get a campaign.
     * Get an update campaign.
     * @param campaignId The campaign ID
     */
    updateCampaignRetrieve(campaignId: string, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
    /**
     * Modify a campaign
     * Modify an update campaign.
     * @param campaignId
     * @param campaign Update campaign
     */
    updateCampaignUpdate(campaignId: string, campaign: UpdateCampaignPutRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: {
        [key: string]: any;
    }): superagent.SuperAgentRequest;
}
